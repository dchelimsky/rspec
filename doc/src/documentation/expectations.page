---
title: Expectation API
---
h2. Expectation API

When RSpec executes specifications, it defines a method <code>should</code> on every object in the system. This <code>should</code> method is your entry to the magic of RSpec.

Almost all expectation forms have a corresponding negated form. It is listed when it is supported and, unless otherwise stated, is met when ever the non-negated form would be violated.

h3. General

h4. Arbitrary Block

<ruby>
target.should_satisfy {|arg| ...}
target.should_not_satisfy {|arg| ...}
</ruby>

The supplied block is evaluated, passing <code>target</code> as the sole argument. If the block evaluates to <code>false</code>, <code>ExpectationNotMetError</code> is raised.

<ruby>
target.should_satisfy {|arg| arg > 0}
</ruby>

h4. Equality

<ruby>
target.should_equal <value>
target.should_not_equal <value>
</ruby>

The target object is compared to <code>value</code> using ==. If the result is <code>false</code>, <code>ExpectationNotMetError</code> is raised.

h4. Floating Point Comparison

<ruby>
target.should_be_close <value>, <tolerance>
target.should_not_be_close <value>, <tolerance>
</ruby>

The target object is compared to <code>value</code>. If they differ by more that <code>tolerance</code>, <code>ExpectationNotMetError</code> is raised. In the negated case, <code>ExpectationNotMetError</code> is raised if they differ by less than <code>tolerance</code>.

<ruby>
target.should_be_close 27.35, 0.05
</ruby>

h4. Identity

<ruby>
target.should_be <value>
target.should_not_be <value>
</ruby>

The target object is compared to <code>value</code> using <code>equal?</code>. If the result is <code>false</code>, <code>ExpectationNotMetError</code> is raised.

h4. Arbitrary Predicate

<ruby>
target.should_predicate [optional args]
target.should_be_predicate [optional args]
target.should_not_predicate [optional args]
target.should_not_be_predicate [optional args]
</ruby>

The message <code>predicate?</code> is sent to <code>target</code> with any supplied arguments. If the result is <code>false</code>, <code>ExpectationNotMetError</code> is raised.

For example:

<ruby>
container.should_include('a') => container.include?('a')
container.should_be_empty => container.empty?
</ruby>

h4. Arbitrary Operators

<ruby>
target.should_be < 6
target.should_be <= 5
target.should == 5
target.should_be >= 5
target.should_be > 4
target.should == 'Johnny'
target.should_not == 'Samantha'
</ruby>

The operators are sent to <code>target</code> with supplied arguments. Note that while you can use <code>should_not ==</code>, the expression <code>should !=</code> does not work.

h4. Pattern Matching

<ruby>
target.should_match <regex>
target.should_not_match <regex>
</ruby>

The <code>target</code> is matched against <code>regex</code>. An <code>ExpectationNotMetError</code> is raised if the match fails.

h3. Class/Type

h4. Direct Instance

<ruby>
target.should_be_an_instance_of <class>
target.should_not_be_an_instance_of <class>
</ruby>

An <code>ExpectationNotMetError</code> is raised if <code>target</code> is not or is, respectively, an direct instance of <code>class</code>. As expected this correlates to <code>target.instance_of?  class</code>.

h4. Ancestor Class

<ruby>
target.should_be_a_kind_of <class>
target.should_not_be_a_kind_of <class>
</ruby>

As above, but uses <code>target.kind_of? class</code>: checking whether <code>class</code> is the direct class of <code>target</code>, or an ancestor of <code>target</code>'s direct class.

h4. Type

<ruby>
target.should_respond_to <symbol>
target.should_not_respond_to <symbol>
</ruby>

Uses <code>target.respond_to?(symbol)</code> to check whether <code>symbol</code> is the name of a message that <code>target</code> understands.

h3. Procs

h4. Raising

<ruby>
proc.should_raise <exception>
proc.should_not_raise <exception>
</ruby>

Checks that <code>proc</code> causes the named exception to be raised or not. The latter is actually one of two cases: some other exception is raised, or no exception is raised. Typically the <code>proc</code> is created in place using <code>lambda</code>. For example:

<ruby>
lambda { 3 / 0 }.should_raise ZeroDivisionError
</ruby>

There is a more general form as well.

<ruby>
proc.should_raise
proc.should_not_raise
</ruby>

These forms don't worry about what exception is raised (or not). All they are concerned with is that some except was raised, or that no exception was.

h4. Throwing

<ruby>
proc.should_throw <symbol>
proc.should_not_throw <symbol>
</ruby>

Similar to the above, but checks that <code>symbol</code> is thrown from within <code>proc</code>, or not. The latter is actually one of two cases: some other symbol is thrown, or no symbol is thrown.

<ruby>
proc.should_not_throw
</ruby>

This form is more specific.  It checks that no symbol is thrown from within <code>proc</code>.

h3. Collections

h4. Containment

<ruby>
target.should_include <object>
target.should_not_include <object>
</ruby>

This is simply a specific case of the arbitrary predicate form. It uses <code>target.include?(object)</code> and raises an <code>ExpectationNotMetError</code> if that returns false. 

h4. Size

The remaining collection forms are a little more involved. They rely on two things: 1) <code>target</code> responds to the message <code>things</code> by returning an object that 2) responds to either <code>length</code> or <code>size</code>, which return a number that is a measure of size. Currently <code>length</code> is used if is appropriate, otherwise <code>size</code> is attempted.

h4. Exact Size

<ruby>
target.should_have(<number>).things
</ruby>

The <code>things</code> of <code>target</code> has a length/size of exactly <code>number</code>.

h4. Lower Bound

<ruby>
target.should_have_at_least(<number>).things
</ruby>

The <code>things</code> of <code>target</code> has a length/size of no less than <code>number</code>.

h4. Upper Bound

<ruby>
target.should_have_at_most(<number>).things
</ruby>

The <code>things</code> of <code>target</code> has a length/size of no more than <code>number</code>.
